<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: api.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: api.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * This file contains the rq Javascript API implementation.  It's used by for example `prelude.js`.
 */

/**
 * The `rq` namespace, containing the `rq` API.
 *
 * @namespace
 */
var rq = {};

/**
 * The type of `this` for all of the rq stream processing functions (defined for example in
 * `prelude.js`)
 *
 * @param {rq.Logger} log The logger to use in this context.
 * @constructor
 */
rq.Context = function Context(log) {
  /**
   * A logger object that can be used to send log messages to the user.
   *
   * @type {rq.Logger}
   */
  this.log = log; // Writable because Process overwrites it.

  /**
   * The current value from the input value stream.  Will be `undefined` until {@link
    * rq.Context#pull} has been called and returned `true`.
   */
  this.value = undefined;

  /**
   * Pulls the next value in the input value stream, storing it into `this.value`.
   *
   * @return {boolean} Whether there was another value in the stream.
   */
  this.pull = function pull() {
    var result = Duktape.Thread['yield']({type: 'await'});

    if (result.hasNext) {
      this.value = result.next;
      return true;
    } else {
      return false;
    }
  };

  /**
   * Pushes a value into the output value stream.
   *
   * @param {*} value The value to push.
   */
  this.push = function push(value) {
    Duktape.Thread['yield']({type: 'emit', value: value});
  };

  /**
   * Collects all values from the input stream, consuming it fully.
   *
   * @returns {Array} The values that were in the input stream.
   */
  this.collect = function collect() {
    var result = [];
    while (this.pull()) {
      result.push(this.value);
    }
    return result;
  };

  /**
   * Spreads the specified values into the output stream, pushing each of them in order.
   *
   * @param {Array} values The values to push to the output stream.
   */
  this.spread = function spread(values) {
    for (var i = 0; i &lt; values.length; i++) {
      this.push(values[i]);
    }
  };

  Object.seal(this);
};

/**
 * A logger that can be used to log messages.
 *
 * @param {string} name The name of the logger.
 * @constructor
 */
rq.Logger = function Logger(name) {
  this.log = new Duktape.Logger(name);
  this.log.l = 0;

  /**
   * Logs something at the trace level.
   *
   * @param {...*} args Arbitrary values to log.
   */
  this.trace = function trace(args) {
    this.log.trace.apply(this.log, arguments);
  };

  /**
   * Logs something at the debug level.
   *
   * @param {...*} args Arbitrary values to log.
   */
  this.debug = function debug(args) {
    this.log.debug.apply(this.log, arguments);
  };

  /**
   * Logs something at the info level.
   *
   * @param {...*} args Arbitrary values to log.
   */
  this.info = function info(args) {
    this.log.info.apply(this.log, arguments);
  };

  /**
   * Logs something at the warning level.
   *
   * @param {...*} args Arbitrary values to log.
   */
  this.warn = function warn(args) {
    this.log.warn.apply(this.log, arguments);
  };

  /**
   * Logs something at the error level.
   *
   * @param {...*} args Arbitrary values to log.
   */
  this.error = function error(args) {
    this.log.error.apply(this.log, arguments);
  };

  /**
   * Logs something at the fatal level.
   *
   * @param {...*} args Arbitrary values to log.
   */
  this.fatal = function fatal(args) {
    this.log.fatal.apply(this.log, arguments);
  };

  Object.freeze(this);
};

/**
 * Utility functions used by many rq processes.
 *
 * @namespace
 */
rq.util = {};

/**
 * The log object used by this module.
 *
 * @type {rq.Logger}
 */
Object.defineProperty(rq.util, 'log', {value: new rq.Logger('rq.util')});

/**
 * A lens that can be used to interact with some encapsulated value.
 *
 * @param {function(): *} get The getter for the value.
 * @param {function(*)} set The setter for the value.
 * @constructor
 */
rq.util.Lens = function Lens(get, set) {
  /**
   * Gets the encapsulated value.
   * @return {*} The current value.
   */
  this.get = get;

  /**
   * Sets the encapsulated value.
   * @param {*} value The new value to set.
   */
  this.set = set;

  Object.freeze(this);
};

/**
 * Evaluates a path into an object, returning an array of `Lens`es with the targets of the path.
 *
 * The supported path syntaxes include [JSONPath][1] and [JSON pointers][2].
 *
 * [1]: https://github.com/dchester/jsonpath
 * [2]: https://tools.ietf.org/html/rfc6901
 *
 * @param {(Object|Array)} obj The object to traverse.
 * @param {string} path The path into the object.
 * @return {Array&lt;rq.util.Lens>} A lens that can be used to manipulate the targeted values.
 */
rq.util.path = function path(obj, path) {
  if (typeof path === 'string' &amp;&amp; path.length > 0) {
    if (path.charAt(0) === '/') {
      // Assume it's a JSON pointer

      var elems = path.substring(1).split(/\//).map(function unescape(elem) {
        return elem.replace(/~1/g, '/').replace(/~2/g, '~');
      });

      if (elems.length === 0) {
        throw new Error('Path projection is empty: ' + JSON.stringify(path));
      }

      var last = elems.pop();

      elems.forEach(function(elem) {
        if (obj &amp;&amp; elem in obj) {
          obj = obj[elem];
        } else {
          obj = undefined;
        }
      });

      if (obj &amp;&amp; last in obj) {
        return [new rq.util.Lens(function get() {
          return obj[last];
        }, function set(v) {
          obj[last] = v;
        })];
      } else {
        return [];
      }
    } else if (path.charAt(0) == '$') {
      // Assume it's a JSON path

      var jp = require('jsonpath');

      return jp.paths(obj, path).map(function(innerPath) {
        return new rq.util.Lens(function get() {
          return jp.value(obj, innerPath);
        }, function set(v) {
          jp.value(obj, innerPath, v);
        })
      });
    } else {
      throw new Error('Unrecognized path syntax: ' + JSON.stringify(path));
    }
  } else {
    throw new Error('Cannot be used as a path: ' + JSON.stringify(path));
  }
};

Object.freeze(rq.util);

/**
 * An rq process that encapsulates a coroutine.  It's probably not a good idea to construct an
 * instance of this manually.
 *
 * @constructor
 */
rq.Process = function Process(fn) {
  var ctx = new rq.Context(new rq.Logger(fn.fileName + '/' + fn.name));
  var boundFn = fn.bind(ctx);

  this.run = function run(args) {
    // Replace logger by more detailed one
    var name = fn.fileName + '/' + fn.name + '(' + args.map(JSON.stringify).join(', ') + ')';
    ctx.log = new rq.Logger(name);

    // TODO: Right now, Duktape doesn't support Function.prototype.apply with coroutines, so we need
    // this hack
    switch (args.length) {
      case 0:
        return boundFn();
      case 1:
        return boundFn(args[0]);
      case 2:
        return boundFn(args[0], args[1]);
      case 3:
        return boundFn(args[0], args[1], args[2]);
      case 4:
        return boundFn(args[0], args[1], args[2], args[3]);
      case 5:
        return boundFn(args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return boundFn(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7:
        return boundFn(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
      case 8:
        return boundFn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
      default:
        throw new Error('For now, only functions with up to 8 arguments are supported');
    }
  };

  this.resume = function resume(thread, result) {
    return Duktape.Thread.resume(thread, result);
  };

  Object.freeze(this);
};

rq.createFunction = function createFunction(args, body) {
  return require('minieval').createFunction(body, args);
};

Object.freeze(rq);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="rq.Context.html">Context</a></li><li><a href="rq.Logger.html">Logger</a></li><li><a href="rq.Process.html">Process</a></li><li><a href="rq.util.Lens.html">Lens</a></li></ul><h3>Namespaces</h3><ul><li><a href="rq.html">rq</a></li><li><a href="rq.util.html">util</a></li></ul><h3>Global</h3><ul><li><a href="global.html#chunk">chunk</a></li><li><a href="global.html#collect">collect</a></li><li><a href="global.html#compact">compact</a></li><li><a href="global.html#concat">concat</a></li><li><a href="global.html#countBy">countBy</a></li><li><a href="global.html#difference">difference</a></li><li><a href="global.html#differenceBy">differenceBy</a></li><li><a href="global.html#differenceWith">differenceWith</a></li><li><a href="global.html#drop">drop</a></li><li><a href="global.html#dropRight">dropRight</a></li><li><a href="global.html#dropRightWhile">dropRightWhile</a></li><li><a href="global.html#dropWhile">dropWhile</a></li><li><a href="global.html#every">every</a></li><li><a href="global.html#fill">fill</a></li><li><a href="global.html#filter">filter</a></li><li><a href="global.html#find">find</a></li><li><a href="global.html#findIndex">findIndex</a></li><li><a href="global.html#findLast">findLast</a></li><li><a href="global.html#findLastIndex">findLastIndex</a></li><li><a href="global.html#first">first</a></li><li><a href="global.html#flatMap">flatMap</a></li><li><a href="global.html#flatMapDeep">flatMapDeep</a></li><li><a href="global.html#flatMapDepth">flatMapDepth</a></li><li><a href="global.html#flatten">flatten</a></li><li><a href="global.html#flattenDeep">flattenDeep</a></li><li><a href="global.html#flattenDepth">flattenDepth</a></li><li><a href="global.html#fromPairs">fromPairs</a></li><li><a href="global.html#groupBy">groupBy</a></li><li><a href="global.html#id">id</a></li><li><a href="global.html#includes">includes</a></li><li><a href="global.html#indexOf">indexOf</a></li><li><a href="global.html#initial">initial</a></li><li><a href="global.html#intersection">intersection</a></li><li><a href="global.html#intersectionBy">intersectionBy</a></li><li><a href="global.html#intersectionWith">intersectionWith</a></li><li><a href="global.html#invokeMap">invokeMap</a></li><li><a href="global.html#join">join</a></li><li><a href="global.html#keyBy">keyBy</a></li><li><a href="global.html#last">last</a></li><li><a href="global.html#lastIndexOf">lastIndexOf</a></li><li><a href="global.html#map">map</a></li><li><a href="global.html#max">max</a></li><li><a href="global.html#maxBy">maxBy</a></li><li><a href="global.html#mean">mean</a></li><li><a href="global.html#meanBy">meanBy</a></li><li><a href="global.html#min">min</a></li><li><a href="global.html#minBy">minBy</a></li><li><a href="global.html#modify">modify</a></li><li><a href="global.html#now">now</a></li><li><a href="global.html#nth">nth</a></li><li><a href="global.html#orderBy">orderBy</a></li><li><a href="global.html#partition">partition</a></li><li><a href="global.html#random">random</a></li><li><a href="global.html#reduce">reduce</a></li><li><a href="global.html#reduceRight">reduceRight</a></li><li><a href="global.html#reject">reject</a></li><li><a href="global.html#reverse">reverse</a></li><li><a href="global.html#sample">sample</a></li><li><a href="global.html#sampleSize">sampleSize</a></li><li><a href="global.html#select">select</a></li><li><a href="global.html#shuffle">shuffle</a></li><li><a href="global.html#size">size</a></li><li><a href="global.html#slice">slice</a></li><li><a href="global.html#some">some</a></li><li><a href="global.html#sortBy">sortBy</a></li><li><a href="global.html#sortedIndex">sortedIndex</a></li><li><a href="global.html#sortedIndexBy">sortedIndexBy</a></li><li><a href="global.html#sortedIndexOf">sortedIndexOf</a></li><li><a href="global.html#sortedLastIndex">sortedLastIndex</a></li><li><a href="global.html#sortedLastIndexBy">sortedLastIndexBy</a></li><li><a href="global.html#sortedLastIndexOf">sortedLastIndexOf</a></li><li><a href="global.html#sortedUniq">sortedUniq</a></li><li><a href="global.html#sortedUniqBy">sortedUniqBy</a></li><li><a href="global.html#spread">spread</a></li><li><a href="global.html#sum">sum</a></li><li><a href="global.html#sumBy">sumBy</a></li><li><a href="global.html#tail">tail</a></li><li><a href="global.html#take">take</a></li><li><a href="global.html#takeRight">takeRight</a></li><li><a href="global.html#takeRightWhile">takeRightWhile</a></li><li><a href="global.html#takeWhile">takeWhile</a></li><li><a href="global.html#tee">tee</a></li><li><a href="global.html#union">union</a></li><li><a href="global.html#unionBy">unionBy</a></li><li><a href="global.html#unionWith">unionWith</a></li><li><a href="global.html#uniq">uniq</a></li><li><a href="global.html#uniqBy">uniqBy</a></li><li><a href="global.html#uniqWith">uniqWith</a></li><li><a href="global.html#unzip">unzip</a></li><li><a href="global.html#unzipWith">unzipWith</a></li><li><a href="global.html#without">without</a></li><li><a href="global.html#xor">xor</a></li><li><a href="global.html#xorBy">xorBy</a></li><li><a href="global.html#xorWith">xorWith</a></li><li><a href="global.html#zip">zip</a></li><li><a href="global.html#zipWith">zipWith</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.1</a> on Mon Sep 19 2016 22:19:22 GMT+0000 (UTC)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
